 --[[
 Ubuntuforums Conky thread Main helper script
 
 changelog:
 v1.1.3 - (11.07.2012) time2angle function no more call os.data when time variables are passed to it
 v1.1.2	- changed time2angle function to work with timezones and ${tztime} Conky object
 v1.1.0 - added hex/dec conversion function
 v1.0.0 - converted to module
 v0.4.0 - improved "time2angle" to more exact number of hour and minute angles and some degree to radian conversion cosmetics
 v0.3.0 - added incremental/decremantal angle function
 v0.2.2 - improved hour angle equasion in "time2angle" function
 v0.2.0 - added function "time2angle"
 v0.1.0 - added first function "pointATcircle"
 ]]
 
 local modname = ...
 local M = {}
 _G[modname] = M
 package.loaded[modname] = M
 
 function M.pointATcircle(x, y, alpha, radius) -- x,y = circle center point, alpha = angle degree (0Â° is 3 o'clock located), radius = circle radius
 	return radius*math.cos(math.rad(alpha))+x, radius*math.sin(math.rad(alpha))+y
 	-- returns (x,y) of point located at "alpha" degree on circle
 end
 
 function M.time2angle(marksTYPE, timeZone, h, m, s) -- marksTYPE = either 12 or 24 marks clock
 	local t = {}
 	if timeZone == nil or timeZone == "local" then tztime="${tztime}" else tztime="${tztime "..timeZone.."}" end
 	if not h or not m or not s then string.gsub(conky_parse(tztime), "(%d+):(%d+):(%d+)", function(a,b,c) loadstring("t = { hour="..a..", min="..b..", sec="..c.." }")() end) end
 	local dayPART=os.date('%p')
 	local circle2hourDIVIDER=30
 
 	if s then t.sec=s end
 	t.sec=tonumber(t.sec)
 	local s_angle=t.sec*6
 	if s_angle > 360 then s_angle=s_angle-360
 	elseif s_angle < 0 then s_angle=360+s_angle end
 
 	if m then t.min=m end
 	t.min=tonumber(t.min)
 	local m_angle=(t.min+(t.sec/60))*6
 	if m_angle > 360 then m_angle=m_angle-360
 	elseif m_angle < 0 then m_angle=360+m_angle end
 
 	if h then t.hour=h end
 	t.hour=tonumber(t.hour)
 	if marksTYPE and marksTYPE==24 and dayPART=='PM' and t.hour<12 then t.hour=t.hour+12 end
 	if marksTYPE and marksTYPE==24 then circle2hourDIVIDER=15 end
 	local h_angle=(t.hour+(t.min/60)+(t.sec/3600))*circle2hourDIVIDER
 	if h_angle > 360 then h_angle=h_angle-360
 	elseif h_angle < 0 then h_angle=360+h_angle end
 
 	return h_angle-90, m_angle-90, s_angle-90 -- returns clockwise cartesian oriented angle ( 0deg at the positive X axis)
 end
 
 function M.increment_angle(number, increment)
 	if number then if number > 360 then number = number-360 end; number = number+increment end
 	return number
 end
 
 function M.decrement_angle(number, decrement)
 	if number then if number < 0 then number = number+360 end; number = number-decrement end
 	return number
 end
 
 function M.curve2angle(curve_thick, radius_thick)
 	return math.deg(curve_thick / radius_thick)
 end
 
 function M.os_capture(cmd, raw)
 	local f = assert(io.popen(cmd, 'r'))
 	local s = assert(f:read('*a'))
 	f:close()
 	if raw then return s end
 	s = string.gsub(s, '^%s+', '')
 	s = string.gsub(s, '%s+$', '')
 	s = string.gsub(s, '[\n\r]+', ' ')
 	return s
 end
 
 function M.netDEV(_dev)
 	local _netSTATE
 	local _net = io.open('/sys/class/net/'.._dev..'/operstate')
 	if _net then
 		_netSTATE = _net:read()
 		_net:close()
 	else return nil
 	end
 	if _netSTATE == "down" then return nil else return 0 end
 end
 
 function M.cpuinfo()
 	local cpuinfo = {}
 	for line in io.lines("/proc/cpuinfo") do
 		local key, value = string.match(line, "(.-)%s*: (.+)")
 		if key and value then
 			cpuinfo[key] = value
 		end
 	end
 	return cpuinfo
 end
 
 function M.hex2dec(_hex)
 	return tonumber(_hex, 10)
 end
 
 function M.dec2hex(_dec)
 	local hex_table = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
 	local divide_table = { 1048576, 65536, 4096, 256, 16, 1 }
 	local _t, _hex = 0, '0x'
 	for i in pairs(divide_table) do
 		_t = math.floor(_dec/divide_table[i])
 		_hex = _hex .. hex_table[_t+1]
 		_dec = _dec - _t * divide_table[i]
 	end
 	return _hex
 end
